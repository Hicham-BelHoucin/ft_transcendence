// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserStatus {
  ONLINE
  INGAME
  OFFLINE
}

enum Ladder {
  BEGINNER
  AMATEUR
  SEMI_PROFESSIONAL
  PROFESSIONAL
  WORLD_CLASS
  LEGENDARY
}

// enum Achievements {
// PERFECT_GAME // : Achieve a score of 11-0 in a single game against the computer or another player.
// COMEBACK_KING // : Win a game after being down by 5 or more points.
// SHARP_SHOOTER // : Score 10 or more points in a row without missing a shot.
// IRON_PADDLE // : Block 50 or more shots in a single game.
// MARATHON_MATCH // : Play a game that lasts more than 10 minutes.
// MASTER_OF_SPIN // : Score a point with a spin shot that confuses the opponent.
// SPEED_DEMON // : Score a point within 10 seconds of the start of a game.
// TRICKSTER // : Score a point by bouncing the ball off the wall or the paddle.
// STREAKER // : Win 10 or more games in a row against the computer or other players.
// First_Serve // : Serve your first ball in a game.
// Paddle_Master // : Score 10 points using only your paddle.
// Speed_Demon // : Reach a ball speed of 100 mph.
// Perfect_Aim // : Score five consecutive direct hits on your opponent's paddle.
// Flawless_Victory // : Win a game without your opponent scoring a single point.
// Comeback_Kid // : Win a game after being down by five points.
// Sharp_Shooter // : Score a point with a precise shot that grazes the edge of the paddle.
// Untouchable //  Play for one minute without your opponent touching the ball.
// Long_Rally // : Successfully rally the ball 20 times without anyone scoring a point.
// Quick_Reflexes // : Score a point within three seconds of the ball being served.
// Defensive_Prodigy // : Successfully block 10 consecutive shots from your opponent.
// Master_of //  Spin: Apply spin to the ball and make it curve around your opponent's paddle.
// Unstoppable_Streak // : Win five games in a row without losing a single one.
// Perfect_Defense // : Win a game without allowing your opponent to score a single point.
// Precision_Shot // : Score a point by hitting the ball directly into one of the corners.
// Doubles_Champion // : Win a doubles match with a teammate against two opponents.
// Nail_Biter // : Win a game by a margin of only one point.
// Paddle_Acrobat // : Perform a successful trick shot by hitting the ball behind your back.
// Mind_Reader // : Anticipate your opponent's shot and successfully block it five times in a row.
// Crazy_Comeback // : Win a game after being down by eight points.
// Power_Serve // : Serve the ball with such force that your opponent cannot return it.
// Pinpoint_Accuracy // : Score three consecutive points by hitting the ball to the exact same spot on your opponent's side.
// Legendary_Rivalry // : Play against a specific opponent 100 times.
// Paddle_Wizard // : Win a game without moving your paddle from the center position.
// Pong_Champion // : Win 100 games in total.
// }

model User {
  id                    Int             @id @default(autoincrement())
  login                 String          @unique
  username              String          @unique
  email                 String          @unique
  password              String?
  fullname              String
  country               String
  phone                 String
  avatar                String
  twoFactorAuth         Boolean         @default(false)
  tfaSecret             String
  status                UserStatus      @default(OFFLINE)
  ladder                Ladder          @default(BEGINNER)
  rating                Int             @default(0)
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  blocking              Block[]         @relation("blocking")
  blockers              Block[]         @relation("blocker")
  wins                  Int             @default(0)
  losses                Int             @default(0)
  mutedIn               Channel[]       @relation("mutedinChannels")
  bannedIn              Channel[]       @relation("bannedinChannels")
  kickedIn              Channel[]       @relation("kickedinChannels")
  adminIn               Channel[]       @relation("admininChannels")
  ownedChannels         Channel[]       @relation("ownedChannels")
  pinnedChannels        Channel[]       @relation("pinnedChannels")
  mutedChannels         Channel[]       @relation("mutedChannels")
  archivedChannels      Channel[]       @relation("archivedChannels")
  deletedChannels       Channel[]       @relation("deletedChannels")
  unreadChannels        Channel[]       @relation("unreadChannels")
  achievements          Achievement[]   @relation("AchievementPlayers")
  memberInChannels      ChannelMember[]
  sentMessages          Message[]       @relation("send")
  pineedMessages        Message[]       @relation("pinner")
  sentRequests          Friend[]        @relation("SentRequest")
  receivedRequests      Friend[]        @relation("ReceivedRequest")
  gamesWon              Game[]          @relation("winner")
  gamesLost             Game[]          @relation("loser")
  gamesAsPlayer1        Game[]          @relation("player1")
  gamesAsPlayer2        Game[]          @relation("player2")
  sentNotifications     Notification[]  @relation("sent")
  receivedNotifications Notification[]  @relation("received")
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model Friend {
  id         Int           @id @default(autoincrement())
  sender     User          @relation("SentRequest", fields: [senderId], references: [id])
  senderId   Int
  receiver   User          @relation("ReceivedRequest", fields: [receiverId], references: [id])
  receiverId Int
  status     RequestStatus @default(PENDING)
}

model Achievement {
  id          Int     @id @default(autoincrement())
  name        String
  description String
  image       String?
  players     User[]  @relation("AchievementPlayers")
}

model Block {
  blocker    User @relation("blocker", fields: [blockerId], references: [id])
  blockerId  Int
  blocking   User @relation("blocking", fields: [blockingId], references: [id])
  blockingId Int

  @@id([blockerId, blockingId])
}

enum Visiblity {
  PUBLIC
  PRIVATE
  PROTECTED
}

enum ChannelType {
  GROUP
  CONVERSATION
}

model Channel {
  id                 Int             @id @default(autoincrement())
  name               String
  avatar             String
  visiblity          Visiblity       @default(PUBLIC)
  password           String?
  accessPassword     String?
  isacessPassword    Boolean         @default(false)
  owner              User            @relation("ownedChannels", fields: [userId], references: [id])
  pinnedFor          User[]          @relation("pinnedChannels")
  mutedFor           User[]          @relation("mutedChannels")
  archivedFor        User[]          @relation("archivedChannels")
  deletedFor         User[]          @relation("deletedChannels")
  unreadFor          User[]          @relation("unreadChannels")
  bannedUsers        User[]          @relation("bannedinChannels")
  mutedUsers         User[]          @relation("mutedinChannels")
  kickedUsers        User[]          @relation("kickedinChannels")
  adminUsers         User[]          @relation("admininChannels")
  userId             Int
  type               ChannelType     @default(GROUP)
  channelMembers     ChannelMember[] @relation("membersInChannels")
  createAt           DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  messages           Message[]       @relation("receive")
  lastestMessageDate DateTime?       @default(now())
  newMessagesCount   Int?            @default(0)
}

enum Role {
  MEMEBER
  ADMIN
}

enum MemberStatus {
  MUTED
  BANNED
  ACTIVE
}

model ChannelMember {
  user         User         @relation(fields: [userId], references: [id])
  userId       Int
  channel      Channel      @relation("membersInChannels", fields: [channelId], references: [id])
  channelId    Int
  role         Role         @default(MEMEBER)
  status       MemberStatus @default(ACTIVE)
  banStartTime DateTime?
  banDuration  Int?

  @@id([userId, channelId])
}

model Message {
  id         Int      @id @default(autoincrement())
  content    String
  receiver   Channel  @relation("receive", fields: [receiverId], references: [id])
  receiverId Int
  sender     User     @relation("send", fields: [senderId], references: [id])
  senderId   Int
  pinned     Boolean? @default(false)
  pinner     User?    @relation("pinner", fields: [pinnerId], references: [id])
  pinnerId   Int?
  date       DateTime @default(now())
}

enum GameStatus {
  PENDING
  IN_PROGRESS
  FINISHED
}

model Game {
  id           Int        @id @default(autoincrement())
  player1      User       @relation("player1", fields: [player1Id], references: [id])
  player1Id    Int
  player2      User       @relation("player2", fields: [player2Id], references: [id])
  player2Id    Int
  winner       User?      @relation("winner", fields: [winnerId], references: [id])
  winnerId     Int?
  loser        User?      @relation("loser", fields: [loserId], references: [id])
  loserId      Int?
  date         DateTime   @default(now())
  player1Score Int        @default(0)
  player2Score Int        @default(0)
  status       GameStatus @default(IN_PROGRESS)
}

model Notification {
  id         Int      @id @default(autoincrement())
  title      String
  content    String
  url        String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  seen       Boolean  @default(false)
  senderId   Int
  receiverId Int
  sender     User     @relation("sent", fields: [senderId], references: [id])
  receiver   User     @relation("received", fields: [receiverId], references: [id])
}
